! function() {
    if ("performance" in window == !1 && (window.performance = {}), Date.now = Date.now || function() {
            return (new Date).getTime()
        }, "now" in window.performance == !1) {
        var n = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart : Date.now();
        window.performance.now = function() {
            return Date.now() - n
        }
    }
}();
var MORPH = function() {
    var n = [];
    return {
        add: function(r) {
            n.push(r)
        },
        update: function(r) {
            if (0 === n.length) return !1;
            var e = 0,
                o = n.length;
            for (r = void 0 !== r ? r : window.performance.now(); o > e;) n[e].update(r) ? e++ : (n.splice(e, 1), o--);
            return !0
        },
        draw: function(r) {
            for (var e = 0, o = n.length; o > e;) {
                var a = n[e++];
                a.draw(r)
            }
        },
        clear: function() {
            n = []
        }
    }
}();
MORPH.MorphablePath = function(n) {
    return {
        morphableGroups: n
    }
}, MORPH.createMorphablePath = function(n, r) {
    for (var e = [], o = n.length, a = r.length, t = Math.min(o, a), i = 0, u = 0, w = 0; t > w; w++) {
        var p = [],
            f = [];
        if (a > o)
            for (i = w, p.push(n[i]); w + 1 > u * (o / a) && a > u;) f.push(r[u]), u++;
        else
            for (u = w, f.push(r[u]); w + 1 > i * (a / o) && o > i;) p.push(n[i]), i++;
        p.length !== f.length ? e.push(new MORPH.MorphableGroup(p, f)) : e.push(new MORPH.MorphableGroupParallel(p, f))
    }
    return new MORPH.MorphablePath(e)
};
MORPH.Morph = function(t, h) {
    h = h || {}, this._paths = t, this._current = 0, this._morphablePathCollection = [], this._ratio = 0, this._startTime, this._duration = h.duration || 1e3, this._delayTime = 0, this._looping = h.looping || !1, this._numPaths = this._looping ? this._paths.length + 1 : this._paths.length, this._completeCallback = h.onComplete, this._x = 0, this._y = 0, this.reset()
}, MORPH.Morph.prototype = {
    reset: function() {
        var t = 0;
        if (this._numPaths > 1)
            for (this._morphablePathCollection = []; this._morphablePathCollection.length < this._numPaths - 1;) {
                var h = MORPH.createMorphablePath(this._paths[t].getSegments(), this._paths[(t + 1) % this._paths.length].getSegments());
                this._morphablePathCollection.push(h), t++
            } else this._morphablePathCollection.push(this._paths[0])
    },
    start: function(t) {
        return this._startTime = void 0 !== t ? t : window.performance.now(), this._startTime += this._delayTime, MORPH.add(this), this
    },
    update: function(t) {
        var h, i = 0,
            e = Math.max(0, Math.min(1, (t - this._startTime) / this._duration));
        return (h = this.setRatio(e)) ? (null != this._completeCallback && this._completeCallback(), this._looping ? (this._startTime = void 0 !== t ? t : window.performance.now(), this._current = 0, this._ratio = 0, !0) : !1) : (this._current = i, !0)
    },
    getCurrentPath: function() {
        return this._paths[this._paths.length - 1]
    },
    setRatio: function(t) {
        return this._ratio = t, this._numPaths > 1 ? (index = Math.floor(this._ratio * (this._numPaths - 1)), index >= this._numPaths - 1) : this._ratio >= 1
    },
    getCurrentRatio: function() {
        var t = this._ratio * (this._numPaths - 1) - this._current;
        return t
    },
    getCurrentMorphablePath: function() {
        return this._current < this._morphablePathCollection.length ? this._morphablePathCollection[this._current] : void console.log("Error : something wrong here!")
    },
    getShape: function() {
        if (this._numPaths > 1) return this.currentShape();
        var t = this._paths[0];
        return new MORPH.Shape(t.getSegments())
    },
    currentShape: function() {
        for (var t = this.getCurrentMorphablePath().morphableGroups, h = this.getCurrentRatio(), i = t.length, e = [], s = 0; i > s; s++) {
            var n = t[s],
                r = n.interpolate(h);
            e = e.concat(r)
        }
        return new MORPH.Shape(e)
    },
    onComplete: function(t) {
        return this._onCompleteCallback = t, this
    },
    setScale: function(t) {
        return this._paths.forEach(function(h) {
            h.setScale(t)
        }), this.reset(), this
    },
    getWidth: function() {
        for (var t = 0, h = 0; h < this._paths.length; h++) this._paths[h].width() > t && (t = this._paths[h].width());
        return t
    },
    getHeight: function() {
        for (var t = 0, h = 0; h < this._paths.length; h++) this._paths[h].height() > t && (t = this._paths[h].height());
        return t
    },
    translate: function(t, h) {
        return this._x += t, this._y += h, this._paths.forEach(function(i) {
            i.translate(t, h)
        }), this.reset(), this
    },
    setOrigin: function(t, h) {
        var i = this._x - t,
            e = this._y - h;
        return this._paths.forEach(function(t) {
            t.translate(i, e)
        }), this.reset(), this
    },
    getX: function() {
        return this._x
    },
    getY: function() {
        return this._y
    }
};
MORPH.Shape = function(t) {
    this.segmentCollection = t || [], this.length = this.segmentCollection.length
}, MORPH.Shape.prototype = {
    translate: function(t, e) {
        for (var n = 0; n < this.length; n++) this.segmentCollection[n].translate(t, e)
    },
    scale: function(t) {
        for (var e = 0; e < this.length; e++) this.segmentCollection[e].scale(t)
    },
    clone: function() {
        for (var t = [], e = 0; e < this.length; e++) t.push(this.segmentCollection[e].clone());
        return new MORPH.Shape(t)
    }
};
MORPH.Segment = function(t, i, s, h) {
    this.pt1 = null !== t ? {
        x: t.x,
        y: t.y
    } : {
        x: 0,
        y: 0
    }, this.pt2 = null !== s ? {
        x: s.x,
        y: s.y
    } : {
        x: 0,
        y: 0
    }, this.ctrl2 = h || {
        x: s.x,
        y: s.y
    }, this.ctrl1 = i || {
        x: t.x,
        y: t.y
    }
}, MORPH.Segment.prototype = {
    interpolate: function() {},
    draw: function(t) {
        t.bezier(this.pt1.x, this.pt1.y, this.ctrl1.x, this.ctrl1.y, this.ctrl2.x, this.ctrl2.y, this.pt2.x, this.pt2.y)
    },
    translate: function(t, i) {
        this.pt1.x += t, this.pt1.y += i, this.pt2.x += t, this.pt2.y += i, this.ctrl1.x += t, this.ctrl1.y += i, this.ctrl2.x += t, this.ctrl2.y += i
    },
    scale: function(t, i) {
        var s = {
                x: (this.ctrl1.x - this.pt1.x) * t,
                y: (this.ctrl1.y - this.pt1.y) * t
            },
            h = {
                x: (this.ctrl2.x - this.pt2.x) * t,
                y: (this.ctrl2.y - this.pt2.y) * t
            };
        this.pt1.x *= t, this.pt1.y *= t, this.pt2.x *= t, this.pt2.y *= t, this.ctrl1.x = this.pt1.x + s.x, this.ctrl1.y = this.pt1.y + s.y, this.ctrl2.x = this.pt2.x + h.x, this.ctrl2.y = this.pt2.y + h.y
    },
    clone: function() {
        return new MORPH.Segment({
            x: this.pt1.x,
            y: this.pt1.y
        }, {
            x: this.ctrl1.x,
            y: this.ctrl1.y
        }, {
            x: this.pt2.x,
            y: this.pt2.y
        }, {
            x: this.ctrl2.x,
            y: this.ctrl2.y
        })
    }
};
MORPH.MorphSegment = function(t, e) {
    this.origSeg = t, this.destSeg = e, this.ctrlV1 = new MORPH.GEOM.Vector(this.destSeg.ctrl1.x - this.origSeg.ctrl1.x, this.destSeg.ctrl1.y - this.origSeg.ctrl1.y), this.ctrlV2 = new MORPH.GEOM.Vector(this.destSeg.ctrl2.x - this.origSeg.ctrl2.x, this.destSeg.ctrl2.y - this.origSeg.ctrl2.y), this.interpolate = function(t) {
        var e = MORPH.GEOM.InterpolatePt(this.origSeg.pt1, this.destSeg.pt1, t),
            r = MORPH.GEOM.InterpolatePt(this.origSeg.pt2, this.destSeg.pt2, t),
            i = this.ctrlV1.Interpolate(t),
            g = {
                x: i.x + this.origSeg.ctrl1.x,
                y: i.y + this.origSeg.ctrl1.y
            };
        i = this.ctrlV2.Interpolate(t);
        var s = {
            x: i.x + this.origSeg.ctrl2.x,
            y: i.y + this.origSeg.ctrl2.y
        };
        return new MORPH.Segment(e, g, r, s)
    }
};
MORPH.MorphableGroup = function() {
    var t = function(t, e) {
        this._origSegs = t || [], this._destSegs = e || [], this._heteromorphic = t.length != e.length, this._maxLength = Math.max(this._origSegs.length, this._destSegs.length), this._segs, this._startSegs, this._endSegs, this._interSeg, this.init()
    };
    return t.prototype = {
        init: function() {
            this._destSegs.length > 1 ? this._interSeg = new MORPH.Segment(MORPH.GEOM.InterpolatePt(this._origSegs[0].pt1, this._destSegs[0].pt1, .5), null, MORPH.GEOM.InterpolatePt(this._origSegs[this._origSegs.length - 1].pt2, this._destSegs[this._destSegs.length - 1].pt2, .5), null) : this._interSeg = this._destSegs[0].clone(), this._segs = this._startSegs = this.defineStartInterSegs()
        },
        defineStartInterSegs: function() {
            var t, e, s, i = [];
            s = this._interSeg.pt1;
            for (var n = 0; n < this._origSegs.length;) {
                t = (n + 1) / this._origSegs.length, e = {
                    x: s.x,
                    y: s.y
                }, s = MORPH.GEOM.InterpolatePt(this._interSeg.pt1, this._interSeg.pt2, t);
                var h = new MORPH.Segment(e, null, s, null);
                i.push(new MORPH.MorphSegment(this._origSegs[n], h)), n++
            }
            return i
        },
        defineEndInterSegs: function() {
            var t, e, s, i = [];
            s = this._interSeg.pt1;
            for (var n = 0; n < this._destSegs.length;) {
                t = (n + 1) / this._destSegs.length, e = {
                    x: s.x,
                    y: s.y
                }, s = MORPH.GEOM.InterpolatePt(this._interSeg.pt1, this._interSeg.pt2, t);
                var h = new MORPH.Segment(e, null, s, null);
                i.push(new MORPH.MorphSegment(h, this._destSegs[n])), n++
            }
            return i
        },
        interpolateHetero: function(t) {
            return t >= .5 ? (this._endSegs || (this._endSegs = this.defineEndInterSegs(this._interSeg.pt1, this._destSegs)), this._segs = this._endSegs) : this._segs = this._startSegs, .5 > t ? t / .5 : (t - .5) / .5
        },
        translate: function(t, e) {
            function s(t, e, s) {
                for (var i = 0, i = 0; i < t.length; i++) t[i].translate(e, s)
            }
            s(this._origSegs, t, e), this._destSegs && s(this._destSegs, t, e), this.init()
        },
        interpolate: function(t) {
            var e = [];
            this._heteromorphic && this._destSegs.length > 1 && (t = this.interpolateHetero(t));
            for (var s = 0; s < this._segs.length; s++) e.push(this._segs[s].interpolate(t));
            return e
        }
    }, t
}();
MORPH.MorphableGroupParallel = function() {
    var t = function() {
        MORPH.MorphableGroup.apply(this, arguments)
    };
    return t.prototype = Object.create(MORPH.MorphableGroup.prototype), t.constructor = MORPH.MorphableGroup, t.prototype.init = function() {
        if (this._segs = [], this._destSegs)
            for (var t = 0; t < this._maxLength; t++) this._segs.push(new MORPH.MorphSegment(this._origSegs[t], this._destSegs[t]));
        else this._segs = this._origSegs
    }, t
}();
MORPH.Path = function(t) {
    this.name = t.name || "", this.id = t.id || "", this._segs = [], this._points = [], this._rect, this._x = 0, this._y = 0;
    var e = t.d,
        n = new MORPH.BoundingBox,
        r = this,
        a = function(t, e) {
            var n = new MORPH.GEOM.Point(Math.floor(t), Math.floor(e));
            M() || o(c(), n), r._points.push(n)
        },
        s = function(t, e, n) {
            var a = c();
            i(a, t, n, e), r._points.push(n)
        },
        o = function(t, e) {
            r._segs.push(new MORPH.Segment(t, t, e, e))
        },
        i = function(t, e, n, a) {
            r._segs.push(new MORPH.Segment(t, e, n, a))
        },
        c = function() {
            return r._points[r._points.length - 1].clone()
        },
        M = function() {
            return 0 == r._points.length
        };
    e = e.replace(/,/gm, " "), e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), e = e.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2"), e = e.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2"), e = e.replace(/([0-9])([+\-])/gm, "$1 $2"), e = e.replace(/(\.[0-9]*)(\.)/gm, "$1 $2"), e = e.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "), e = e.replace(/[\s\r\t\n]+/gm, " "), e = e.replace(/^\s+|\s+$/g, "");
    var h = new MORPH.PATH.PathParser(e);
    for (h.reset(); !h.isEnd();) switch (h.nextCommand(), h.command) {
        case "M":
        case "m":
            var P = h.getAsCurrentPoint();
            for (h.addMarker(P), a(P.x, P.y), n.addPoint(P.x, P.y), h.start = h.current; !h.isCommandOrEnd();) {
                var P = h.getAsCurrentPoint();
                h.addMarker(P, h.start), a(P.x, P.y), n.addPoint(P.x, P.y)
            }
            break;
        case "L":
        case "l":
            for (; !h.isCommandOrEnd();) {
                var d = h.current,
                    P = h.getAsCurrentPoint();
                h.addMarker(P, d), a(P.x, P.y), n.addPoint(P.x, P.y)
            }
            break;
        case "H":
        case "h":
            for (; !h.isCommandOrEnd();) {
                var u = new MORPH.GEOM.Point((h.isRelativeCommand() ? h.current.x : 0) + h.getScalar(), h.current.y);
                h.addMarker(u, h.current), h.current = u, a(u.x, u.y), n.addPoint(h.current.x, h.current.y)
            }
            break;
        case "V":
        case "v":
            for (; !h.isCommandOrEnd();) {
                var u = new MORPH.GEOM.Point(h.current.x, (h.isRelativeCommand() ? h.current.y : 0) + h.getScalar());
                h.addMarker(u, h.current), h.current = u, a(u.x, u.y), n.addPoint(h.current.x, h.current.y)
            }
            break;
        case "C":
        case "c":
            for (; !h.isCommandOrEnd();) {
                var x = h.current,
                    y = h.getPoint(),
                    O = h.getAsControlPoint(),
                    g = h.getAsCurrentPoint();
                h.addMarker(g, O, y), s(new MORPH.GEOM.Point(y.x, y.y), new MORPH.GEOM.Point(O.x, O.y), new MORPH.GEOM.Point(g.x, g.y)), n.addBezierCurve(x.x, x.y, y.x, y.y, O.x, O.y, g.x, g.y)
            }
            break;
        case "S":
        case "s":
            for (; !h.isCommandOrEnd();) {
                var x = h.current,
                    y = h.getReflectedControlPoint(),
                    O = h.getAsControlPoint(),
                    g = h.getAsCurrentPoint();
                h.addMarker(g, O, y), s(new MORPH.GEOM.Point(y.x, y.y), new MORPH.GEOM.Point(O.x, O.y), new MORPH.GEOM.Point(g.x, g.y)), n.addBezierCurve(x.x, x.y, y.x, y.y, O.x, O.y, g.x, g.y)
            }
            break;
        case "Q":
        case "q":
            for (; !h.isCommandOrEnd();) {
                var x = h.current,
                    O = h.getAsControlPoint(),
                    g = h.getAsCurrentPoint();
                h.addMarker(g, O, O), s(new MORPH.GEOM.Point(y.x, y.y), new MORPH.GEOM.Point(O.x, O.y), new MORPH.GEOM.Point(g.x, g.y)), n.addQuadraticCurve(x.x, x.y, O.x, O.y, g.x, g.y)
            }
            break;
        case "T":
        case "t":
            for (; !h.isCommandOrEnd();) {
                var x = h.current,
                    O = h.getReflectedControlPoint();
                h.control = O;
                var g = h.getAsCurrentPoint();
                h.addMarker(g, O, O), s(new MORPH.GEOM.Point(y.x, y.y), new MORPH.GEOM.Point(O.x, O.y), new MORPH.GEOM.Point(g.x, g.y)), n.addQuadraticCurve(x.x, x.y, O.x, O.y, g.x, g.y)
            }
            break;
        case "A":
        case "a":
            for (; !h.isCommandOrEnd();) {
                var x = h.current,
                    l = h.getScalar(),
                    m = h.getScalar(),
                    w = h.getScalar() * (Math.PI / 180),
                    p = h.getScalar(),
                    v = h.getScalar(),
                    g = h.getAsCurrentPoint(),
                    C = new MORPH.GEOM.Point(Math.cos(w) * (x.x - g.x) / 2 + Math.sin(w) * (x.y - g.y) / 2, -Math.sin(w) * (x.x - g.x) / 2 + Math.cos(w) * (x.y - g.y) / 2),
                    H = Math.pow(C.x, 2) / Math.pow(l, 2) + Math.pow(C.y, 2) / Math.pow(m, 2);
                H > 1 && (l *= Math.sqrt(H), m *= Math.sqrt(H));
                var f = (p == v ? -1 : 1) * Math.sqrt((Math.pow(l, 2) * Math.pow(m, 2) - Math.pow(l, 2) * Math.pow(C.y, 2) - Math.pow(m, 2) * Math.pow(C.x, 2)) / (Math.pow(l, 2) * Math.pow(C.y, 2) + Math.pow(m, 2) * Math.pow(C.x, 2)));
                isNaN(f) && (f = 0);
                var R = new MORPH.GEOM.Point(f * l * C.y / m, f * -m * C.x / l),
                    E = new MORPH.GEOM.Point((x.x + g.x) / 2 + Math.cos(w) * R.x - Math.sin(w) * R.y, (x.y + g.y) / 2 + Math.sin(w) * R.x + Math.cos(w) * R.y),
                    _ = function(t) {
                        return Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2))
                    },
                    A = function(t, e) {
                        return (t[0] * e[0] + t[1] * e[1]) / (_(t) * _(e))
                    },
                    G = function(t, e) {
                        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(A(t, e))
                    },
                    k = G([1, 0], [(C.x - R.x) / l, (C.y - R.y) / m]),
                    S = [(C.x - R.x) / l, (C.y - R.y) / m],
                    $ = [(-C.x - R.x) / l, (-C.y - R.y) / m],
                    q = G(S, $);
                A(S, $) <= -1 && (q = Math.PI), A(S, $) >= 1 && (q = 0), 0 == v && q > 0 && (q -= 2 * Math.PI), 1 == v && 0 > q && (q += 2 * Math.PI);
                var b = new MORPH.GEOM.Point(E.x + l * Math.cos((k + (k + q)) / 2), E.y + m * Math.sin((k + (k + q)) / 2));
                h.addMarkerAngle(b, (k + (k + q)) / 2 + (0 == v ? -1 : 1) * Math.PI / 2), h.addMarkerAngle(g, k + q + (0 == v ? -1 : 1) * Math.PI / 2), this.addPoint(b.x, b.y), this.addPoint(g.x, g.y), n.addPoint(g.x, g.y)
            }
            break;
        case "Z":
        case "z":
            h.current = h.start, a(h.start.x, h.start.y)
    }
}, MORPH.Path.prototype = {
    clone: function() {
        var t = new MORPH.Path({
            d: _d
        });
        return t.setRectangle(this._rect.clone()), t.name = this.name, t
    },
    translate: function(t, e) {
        this._x = t, this._y = e;
        for (var n = 0; n < this._segs.length; n++) {
            var r = this._segs[n];
            r.translate(t, e)
        }
        this._rect.translate(t, e)
    },
    setScale: function(t) {
        for (var e = 0; e < this._segs.length; e++) {
            var n = this._segs[e];
            n.scale(t, new MORPH.GEOM.Point(0, 0))
        }
        this._rect.scale(t)
    },
    setRectangle: function(t) {
        this._rect = t
    },
    width: function() {
        return this._rect.width()
    },
    height: function() {
        return this._rect.height()
    },
    getSegments: function() {
        for (var t = [], e = 0; e < this._segs.length; e++) t.push(this._segs[e].clone());
        return t
    },
    getPosition: function() {
        return new MORPH.GEOM.Point(this._x, this._y)
    }
};
MORPH.BoundingBox = function(i, t, h, s) {
    this.x1 = Number.NaN, this.y1 = Number.NaN, this.x2 = Number.NaN, this.y2 = Number.NaN, this.addPoint(i, t), this.addPoint(h, s)
}, MORPH.BoundingBox.prototype = {
    scale: function(i) {
        this.x2 = this.x1 + this.width() * i, this.y2 = this.y1 + this.height() * i
    },
    getX: function() {
        return this.x1
    },
    getY: function() {
        return this.y1
    },
    getWidth: function() {
        return this.x2 - this.x1
    },
    getHeight: function() {
        return this.y2 - this.y1
    },
    addPoint: function(i, t) {
        null != i && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = i, this.x2 = i), i < this.x1 && (this.x1 = i), i > this.x2 && (this.x2 = i)), null != t && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = t, this.y2 = t), t < this.y1 && (this.y1 = t), t > this.y2 && (this.y2 = t))
    },
    addX: function(i) {
        this.addPoint(i, null)
    },
    addY: function(i) {
        this.addPoint(null, i)
    },
    addBoundingBox: function(i) {
        this.addPoint(i.x1, i.y1), this.addPoint(i.x2, i.y2)
    },
    addQuadraticCurve: function(i, t, h, s, n, d) {
        var a = i + 2 / 3 * (h - i),
            o = t + 2 / 3 * (s - t),
            u = a + 1 / 3 * (n - i),
            r = o + 1 / 3 * (d - t);
        this.addBezierCurve(i, t, a, u, o, r, n, d)
    },
    addBezierCurve: function(t, h, s, n, d, a, o, u) {
        var r = [t, h],
            e = [s, n],
            x = [d, a],
            y = [o, u];
        for (this.addPoint(r[0], r[1]), this.addPoint(y[0], y[1]), i = 0; i <= 1; i++) {
            var N = function(t) {
                    return Math.pow(1 - t, 3) * r[i] + 3 * Math.pow(1 - t, 2) * t * e[i] + 3 * (1 - t) * Math.pow(t, 2) * x[i] + Math.pow(t, 3) * y[i]
                },
                f = 6 * r[i] - 12 * e[i] + 6 * x[i],
                c = -3 * r[i] + 9 * e[i] - 9 * x[i] + 3 * y[i],
                P = 3 * e[i] - 3 * r[i];
            if (0 != c) {
                var l = Math.pow(f, 2) - 4 * P * c;
                if (!(0 > l)) {
                    var v = (-f + Math.sqrt(l)) / (2 * c);
                    v > 0 && 1 > v && (0 == i && this.addX(N(v)), 1 == i && this.addY(N(v)));
                    var g = (-f - Math.sqrt(l)) / (2 * c);
                    g > 0 && 1 > g && (0 == i && this.addX(N(g)), 1 == i && this.addY(N(g)))
                }
            } else {
                if (0 == f) continue;
                var B = -P / f;
                B > 0 && 1 > B && (0 == i && this.addX(N(B)), 1 == i && this.addY(N(B)))
            }
        }
    },
    isPointInBox: function(i, t) {
        return this.x1 <= i && i <= this.x2 && this.y1 <= t && t <= this.y2
    }
};
MORPH.SVG = {
    getBoundingBox: function(t) {
        var e = t.getElementsByTagName("svg")[0],
            n = e.attributes,
            s = MORPH.SVG.getNodeValue(n, "x"),
            i = MORPH.SVG.getNodeValue(n, "y"),
            r = MORPH.SVG.getNodeValue(n, "width") || 100,
            a = MORPH.SVG.getNodeValue(n, "height") || 100;
        return new MORPH.GEOM.Rectangle(s, i, r, a)
    },
    getNodeValue: function(t, e) {
        return t[e] ? parseInt(t[e].nodeValue) : null
    },
    getPathStrings: function(t) {
        var e, n = [],
            s = t.getElementsByTagName("path");
        for (e = 0; e < s.length; e++) n.push(s[e].getAttribute("d"));
        var i = t.getElementsByTagName("line");
        for (e = 0; e < i.length; e++) {
            var r = i[e].getAttribute("x1"),
                a = i[e].getAttribute("x2"),
                h = i[e].getAttribute("y1"),
                o = i[e].getAttribute("y2");
            n.push("M" + r + " " + h + " L" + a + " " + o)
        }
        var l = t.getElementsByTagName("polyline");
        for (e = 0; e < l.length; e++) {
            var u = l[e].getAttribute("points");
            u = u.replace(/\s\s+/g, " "), u = u.split(" ");
            for (var g = u.shift().split(","), c = parseFloat(g[0]), m = parseFloat(g[1]), f = "M" + c + " " + m + " "; u.length;) g = u.shift().split(","), g.length && (c = parseFloat(g[0]), m = parseFloat(g[1]), f += "L " + c + " " + m + " ");
            f = f.substr(0, f.length - 2), n.push(f)
        }
        for (var p = t.getElementsByTagName("rect"), e = 0; e < p.length; e++) {
            var d = p[e],
                c = parseFloat(d.getAttribute("x")),
                m = parseFloat(d.getAttribute("y")),
                P = parseFloat(d.getAttribute("width")),
                M = parseFloat(d.getAttribute("height")),
                f = "M" + c + " " + m;
            f += "L" + (c + P) + " " + m + " ", f += "L" + (c + P) + " " + (m + M) + " ", f += "L" + c + " " + (m + M) + " ", f += "L" + c + " " + m, n.push(f)
        }
        return n
    }
}, MORPH.PATH = {
    PathParser: function(t) {
        var e = t || "";
        this.tokens = e.split(" "), this.reset = function() {
            this.i = -1, this.command = "", this.previousCommand = "", this.start = new MORPH.GEOM.Point(0, 0), this.control = new MORPH.GEOM.Point(0, 0), this.current = new MORPH.GEOM.Point(0, 0), this.points = [], this.angles = []
        }, this.isEnd = function() {
            return this.i >= this.tokens.length - 1
        }, this.isCommandOrEnd = function() {
            return this.isEnd() ? !0 : null != this.tokens[this.i + 1].match(/^[A-Za-z]$/)
        }, this.isRelativeCommand = function() {
            switch (this.command) {
                case "m":
                case "l":
                case "h":
                case "v":
                case "c":
                case "s":
                case "q":
                case "t":
                case "a":
                case "z":
                    return !0
            }
            return !1
        }, this.getToken = function() {
            return this.i++, this.tokens[this.i]
        }, this.getScalar = function() {
            return parseFloat(this.getToken())
        }, this.nextCommand = function() {
            this.previousCommand = this.command, this.command = this.getToken()
        }, this.getPoint = function() {
            var t = new MORPH.GEOM.Point(this.getScalar(), this.getScalar());
            return this.makeAbsolute(t)
        }, this.getAsControlPoint = function() {
            var t = this.getPoint();
            return this.control = t, t
        }, this.getAsCurrentPoint = function() {
            var t = this.getPoint();
            return this.current = t, t
        }, this.getReflectedControlPoint = function() {
            return "c" != this.previousCommand.toLowerCase() && "s" != this.previousCommand.toLowerCase() ? this.current : new MORPH.GEOM.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y)
        }, this.makeAbsolute = function(t) {
            return this.isRelativeCommand() && (t.x += this.current.x, t.y += this.current.y), t
        }, this.addMarker = function(t, e, n) {
            null != n && this.angles.length > 0 && null == this.angles[this.angles.length - 1] && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(n)), this.addMarkerAngle(t, null == e ? null : e.angleTo(t))
        }, this.addMarkerAngle = function(t, e) {
            this.points.push(t), this.angles.push(e)
        }, this.getMarkerPoints = function() {
            return this.points
        }, this.getMarkerAngles = function() {
            for (var t = 0; t < this.angles.length; t++)
                if (null == this.angles[t])
                    for (var e = t + 1; e < this.angles.length; e++)
                        if (null != this.angles[e]) {
                            this.angles[t] = this.angles[e];
                            break
                        }
            return this.angles
        }
    },
    ClonePaths: function(t) {
        for (var e = [], n = 0; n < t.length; n++) e.push(t[n]);
        return e
    }
};
MORPH.GEOM = {
    InterpolatePt: function(t, i, n) {
        var h = t.x + (i.x - t.x) * n,
            s = t.y + (i.y - t.y) * n;
        return {
            x: h,
            y: s
        }
    },
    Rectangle: function(t, i, n, h) {
        this.x1 = t, this.y1 = i, this.w = n, this.h = h, this.width = function() {
            return this.w
        }, this.height = function() {
            return this.h
        }, this.scale = function(t) {
            this.w = this.w * t, this.h = this.h * t
        }, this.translate = function(t, i) {
            this.x1 += t, this.y1 += i
        }, this.clone = function() {
            return new MORPH.GEOM.Rectangle(this.x1, this.y1, this.w, this.h)
        }
    },
    Point: function(t, i) {
        this.x = t || 0, this.y = i || 0, this.draw = function(t) {
            t.ellipse(this.x, this.y, 10, 10)
        }, this.clone = function() {
            return new MORPH.GEOM.Point(this.x, this.y)
        }, this.equals = function(t) {
            return this.x == t.x && this.y == t.y
        }, this.trace = function() {
            return "{" + this.x + "," + this.y + "}"
        }, this.applyTransform = function(t) {
            var i = this.x * t[0] + this.y * t[2] + t[4],
                n = this.x * t[1] + this.y * t[3] + t[5];
            this.x = i, this.y = n
        }, this.angleTo = function(t) {
            return Math.atan2(t.y - this.y, t.x - this.x)
        }, this.Interpolate = function(t, i, n) {
            var h = t.x + (i.x - t.x) * n,
                s = t.y + (i.y - t.y) * n;
            return new MORPH.GEOM.Point(h, s)
        }, this.interpolate = function(t, i) {
            var n = this.x + (t.x - this.x) * i,
                h = this.y + (t.y - this.y) * i;
            return new MORPH.GEOM.Point(n, h)
        }, this.translate = function(t, i) {
            var n = this.x + t,
                h = this.y + i;
            this.x = n, this.y = h
        }
    },
    RandomPoint: function(t, i) {
        var n = Math.random() * t,
            h = Math.random() * i;
        return new MORPH.GEOM.Point(n, h)
    },
    Vector: function(t, i) {
        this.x = t || 0, this.y = i || 0, this.Interpolate = function(t) {
            return new MORPH.GEOM.Vector(this.x * t, this.y * t)
        }, this.clone = function() {
            return new MORPH.GEOM.Vector(this.x, this.y)
        }
    }
};
MORPH.LoadShapes = function(t) {
    t.constructor !== Array && (t = [t]);
    for (var e = [], n = 0; n < t.length; n++) e.push(MORPH.LoadShape(t[n]));
    return Promise.all(e)
}, MORPH.CachedPaths = {}, MORPH.LoadShape = function(t) {
    return MORPH.LoadSVG(t.concat()).then(function(t) {
        return new Promise(function(e, n) {
            for (var a = [], r = MORPH.SVG.getBoundingBox(t[0]), o = 0; o < t.length; o++)
                for (var s = t[o].getElementsByTagName("svg")[0], h = s.getAttribute("id"), P = MORPH.SVG.getPathStrings(t[o]), u = 0; u < P.length; u++) {
                    var c = new MORPH.Path({
                        id: h + "_" + u,
                        d: P[u]
                    });
                    c.setRectangle(r.clone()), a.push(c)
                }
            e(a)
        })
    })
}, MORPH.LoadSVG = function(t) {
    return new Promise(function(e, n) {
        function a(n, a) {
            o.push(a), MORPH.CachedPaths[n] = a, t.length ? r(t.shift()) : e(o)
        }

        function r(t) {
            if (MORPH.CachedPaths.hasOwnProperty(t)) a(t, MORPH.CachedPaths[t]);
            else {
                var e = new XMLHttpRequest;
                e.onreadystatechange = function() {
                    4 == e.readyState && 200 == e.status && a(t, e.responseXML)
                }, e.open("GET", t, !0), e.send()
            }
        }
        var o = [];
        r(t.shift())
    })
};
MORPH.CanvasUtils = {
    CreateBuffer: function() {
        var t = document.createElement("canvas"),
            i = t.getContext("2d");
        return {
            canvas: t,
            ctx: i,
            width: -1,
            height: -1,
            invalidated: !1,
            resize: function(t, i) {
                return t && i && (t = Math.floor(t), i = Math.floor(i), this.width !== t || this.height !== i) ? (this.canvas.width = t, this.canvas.height = i, this.width = t, this.height = i, !0) : !1
            },
            clear: function() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
            },
            fill: function(t) {
                this.ctx.fillStyle = t, this.ctx.fillRect(0, 0, this.width, this.height)
            },
            getPixelRatio: function() {
                var t = window.devicePixelRatio || 1,
                    i = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1,
                    e = t / i;
                return e
            }
        }
    }
};
var MorphDrawer = function(r, t, h) {
    function e(r) {
        return r = Math.min(s.length - 1, r), s[r]
    }
    this.shapeArr = new Array;
    var a = r,
        n = h || 1,
        s = t || [new Color(0, 0, 0)];
    this.addShape = function(r) {
        this.shapeArr.length >= a && this.shapeArr.pop(), this.shapeArr.unshift(r)
    }, this.draw = function(r) {
        for (var t, h, s, i = this.shapeArr.length, o = 0; i > o; o++) {
            t = o / a, r.strokeWeight(n), s = e(o), r.stroke(s.r, s.g, s.b, s.a), h = this.shapeArr[o];
            for (var p = 0; p < h.length; p++) {
                var f = h.segmentCollection[p];
                f.draw(r)
            }
        }
    }
};